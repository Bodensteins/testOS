# 中断说明文档

+ ### 初始化
    内核在系统初始化时会进行trap初始化，首先设置sstatus寄存器和SIE寄存器的值以使能S态中断和U态中断。然后将stvec寄存器的值设置为内核中断跳板kernel_trap_vec()的首地址，因为目前系统处于内核态需要处理内核态的中断。最后设置下一次时钟中断的时间间隔。
+ ### 用户态中断
    当内核调度某个进程开始运行时，它会把用户中断跳板user_trap_vec()也就是TRAMPOLINE段的首地址放进stvec寄存器，以便发生用户态中断的时候CPU跳转到这里运行.然后在该进程的trapframe页里保存一些重要信息如内核页表,最后进入return_to_user(),切换运行该进程的页表，恢复该进程的上下文，执行sret执行新创建的进程第一条指令或者回到之前运行过的进程的发生中断的地方继续往下运行。
    &nbsp;
    进程在运行的时候可能发生三种trap，异常、系统调用和设备中断。设备中断又分为时钟中断和其他设备中断。在进程运行的时候，如果发生中断，由于在进程运行之前stvec寄存器的值是user_trap_vec()的首地址，所以CPU会跳转到这里执行，这一部分的代码会将进程的上下文保存在进程的虚拟地址空间中的trapframe页里，最后会切换运行内核的页表，进入真正的用户态trap处理函数user_trap()。这一部分的代码首先会把进程发生中断处的指令地址即sepc的值保存至该进程的trapframe，将stvec的值置为kernel_trap_vec()因为内核在进行中断处理的时候可能发生内核态中断。然后读取scause寄存器的值判断中断发生的原因是异常还是系统调用还是时钟中断还是设备中断，分别进入对应的处理流程中去。值得一提的是，如果是时钟中断，那么当该进程时间片到了的时候内核会将该进程置于就绪态，然后去调度其他进程投入运行。在处理完中断且时间片没到，内核会将该进程投入运行恢复该进程的上下文，并执行sret指令使其回到中断发生处继续往下执行。
+ ### 内核态中断
    内核在运行时可能发生两种trap，异常和设备中断，设备中断又分为时钟中断和其他设备中断。在处于内核态时，系统将stvec的值置为kernel_trap_vec()的首地址，当系统发生中断时，CPU进入kernel_trap_vec执行指令，这一部分的代码是工作是保存现场上下文，并进入真正的内核trap处理函数kernel_trap()，它先保存sepc和sstatus值以便发生中断嵌套的时候将来能够恢复这次中断的这两个寄存器的值，然后通过scause的值判断是时钟中断还是其他设备中断或者指令异常，如果是异常的话就panic，如果是前面两种中断的话就进入对应的处理流程。然后恢复sepc和sstatus寄存器的值，恢复发生内核中断处的上下文，然后调用sret回到发生内核中断的地方继续往后执行。