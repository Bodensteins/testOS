# 设备管理说明文档



### 一、总言

​		设备管理是操作系统重要的一部分，在本次的内核实现中，我们需要管理的设备仅仅只有两部分：SD卡与控制台。关于SD卡和文件系统的内容已经在文件管理说明文档中详述，因此本文档主要说明我们小组的内核如何实现控制台的读写功能，即如和通过外部中断的方式从键盘获取字符串输入，并输出字符串到屏幕。

​		关于控制台的所有功能函数均定义于console.c文件中。



### 二、控制台初始化

​		内核启动时，针对控制台的初始化有三项工作：初始化控制台缓冲区、注册控制台读写函数、初始化PLIC。

#### 1、控制台缓冲区初始化

​		控制台从键盘读入字符后会先将其暂存于缓冲区中待控制台读函数取用。该缓冲区结构体定义于console.h文件中，具体定义如下：

```c
typedef struct console_buffer{
    spinlock spinlock;	//自旋锁
    char input_buffer[CONSOLE_BSIZE];	//键盘输入数据区
    uint64 edit_index;	//键盘已按下的数据大小
    uint64 read_index;	//已被读取的数据大小
    uint64 write_index;		//已写入缓冲区的数据大小
}console_buffer;
```

​		初始化时，`edit_index`、`read_index`、`write_index`三个字段均置0。之后的控制台中断和控制台读取函数将会利用到这些字段。

#### 2、注册控制台读写函数

​		控制台需要向内核注册其读写函数。内核会维护一个设备列表，设备列表是一个device结构体数组，device结构体定义如下：

```c
typedef struct device{
    int (*read)(void* ,int);
    int (*write)(void* ,int);
}device;
```

​		可以看到device结构体中仅仅保存两个函数指针。

​		每个设备有自己的设备号，在我们实现的内核中控制台的设备号设置为1。以设备号为下标可以直接在device数组中索引到其设备读写接口，因此初始化时需要向设备列表中对应的device元素设置其read和write指针，如下所示：

```c
void device_init(){
    dev_list[DEVICE_CONSOLE_NUM].read=read_from_console;
    dev_list[DEVICE_CONSOLE_NUM].write=write_to_console;
}
```

​		这样就完成了设备读写函数的注册。

#### 3、初始化PLIC

​		PLIC（Platform Level Interrupt Controller）在riscv中负责转发外部中断。由于我们小组对这方面并不是很熟悉，因此借鉴了上届参赛队的项目。根据上届的经验，K210并没有S态外部中断，而M态的工作全部由SBI完成了。为了解决这个问题，rustsbi中为外部中断开了个洞，注册了调用函数，调用号为0x9。之后的外部中断通过该入口点进入SBI来处理。

​		对于SBI方面的内容我们小组并不了解，因此只能参考上届参赛队的实现，主要参考项目是xv6-k210。

#### 4、进程打开控制台

​		完成内核的初始化后，第一个用户态进程需要主动打开控制台：

```c
int fd=openat(-100,"/dev/console",0x4);
dup(fd);
dup(fd);
```

​		通过以上代码，使得用户进程的0、1、2三个文件描述符均指向控制台。这样，用户进程就可以使用文件操作的系统调用，如read和write，向控制台进行读写了。第一个进程打开控制台后便不会关闭，而其子进程在创建时均会复制其文件描述符，因此每一个进程均可通过0、1、2三个文件描述符读写控制台。

​		


### 三、控制台读写

#### 1、获取键盘输入到缓冲区

​		当按下一个键盘按键后，即产生一个外部中断，内陷进入外部中断处理函数。通过`plic_claim`函数获取irq值并检测以确认外部中断是否来自键盘。确认irq后通过SBI接口`sbi_console_getchar`获取刚刚输入的字符，并将该字符作为参数调用`console_intr`函数。

​		`console_intr`函数首先判断该字符是否合法。如果合法，则将其写如控制台缓冲区并令缓冲区的`edit_index`字段自增。如果输入的字符是回车或ctrl-d，则判断为键盘输入结束，令`write_index`字段等于`edit_index`，并尝试唤醒正在等待读取键盘输入的进程。若唤醒成功，则将CPU控制权交给该进程，否则直接退出。

#### 2、从缓冲区读取内容

​		用户进程可直接使用`read`系统调用读取控制台输入，参数经过传递后最终到达`read_from_console`函数，该函数声明如下：

```c
int read_from_console(void *dst, int sz)
```

​		dst为指向读取目的地的指针，sz为期望读取的字节数大小。

​		读取数据前，首先检测`sz`的大小是否大于缓冲区内待读取的字节数大小，即`write_index`-`read_index`的大小。如果大于，说明缓冲区中没有足够的字节，则令当前进程阻塞，即将其状态改变为睡眠态并加入等待队列以等待`console_intr`函数将其唤醒；否则，说明缓冲区中的数据足够多，则逐字节将数据读入目的地址，并返回实际读取数据的大小。

#### 3、将字符串写到屏幕

​		用户进程可直接使用`write`系统调用读取控制台输入，参数经过传递后最终到达`write_to_console`函数，该函数声明如下：

```c
int write_to_console(void *src, int sz);
```

​		src为指向写入来源的指针，sz为期望写入的字节数大小。

​		`write_to_console`函数的逻辑非常简单，仅仅是将src指向的位置中的字符串利用`sbi_console_putchar`接口逐字节地输入到屏幕，当检测到待输入的字符为'\0'时结束输入，并返回实际写入数据的大小。
