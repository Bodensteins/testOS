# 文件管理说明文档

### 五、file层

​		file层的工作主要是利用inode层提供的接口，将SD卡、设备、管道等各种资源统一抽象为用户进程可用的文件，将这些文件在进程中以文件描述符的形式交给用户程序处理，并向系统调用提供诸如打开文件、读写文件、关闭文件、创建文件、删除文件等功能的实现。

​		file层的所有数据结构定义于file.h中，功能函数定义于file.c中

#### 1、file层的数据结构

​		file层将操作系统中的各种资源统一抽象为文件，这个抽象的文件由`file`结构体记录并维护，`file`结构体将SD卡上的文件、控制台、管道等全部封装到一起，并记录文件的属性、偏移、被引用的数量等。`file`结构体的具体定义如下：

```c
//文件结构体
typedef struct file{
    int type;   //文件类型
    fat32_dirent *fat32_dirent; //文件目录项
    int attribute; //属性
    int dev;    //设备号
    pipe *pipe;  //管道
    int ref_count;  //文件被引用数量
    uint32 offset;  //文件当前的偏移量
}file;
```

​		对于内核而言，每个打开的文件都是这样的一个`file`结构体。内核会维护一个打开文件列表，这个列表记录了所有进程打开的所有文件，该文件列表定义如下：

```c
#define NFILE 128   //OS允许的文件打开数量上限   
//所有打开的文件的列表，由OS维护
typedef struct file_table{
    spinlock spinlock;  //自旋锁
    file file[NFILE];   //打开的文件列表
}file_table;
```

​		对于进程而言，其操作文件的句柄是一个被称为文件描述符的整数。当进程操作文件时，其将文件描述符作为参数来索引打开的文件。因此，每个进程需要有一个列表来维护自己所打开的文件，并且该列表可以文件描述符为索引找到指定的文件。在代表进程PCB的`process`结构体中维护了一个进程打开的文件列表，如下所示：

```c
//进程打开的文件列表，通过文件描述符来索引
  //这个列表维护的实际上是指向file.c中的文件列表的指针，打开的文件最终由OS维护
  file *open_files[N_OPEN_FILE];  
```

​		该列表维护的是一系列`file`结构体指针，当进程初始化时，列表中的所有指针全部指向`NULL`，表示还未打开任何文件。当进程需要打开文件时，内核便在该进程对应的`open_files`列表中寻找一个值为`NULL`的项，令该项指向指定打开的文件的`file`结构体（而`file`结构体在之前所述的`file_table`列表中维护），同时将该项的下标值作为该文件在该进程中的文件描述符交给用户进程。之后需要操作该文件时，系统调用传入文件描述符，内核使用文件描述符直接在该进程`process`结构体中的`open_files`列表中索引到`file`结构体指针，便可获取文件的相应信息并进行进程要求的操作。



#### 2、file层的接口

​		本节将会以一个文件的打开、读写、关闭为例阐述file层如何对底层的接口进行封装并向上层提供实际执行系统调用功能的接口。

（1）、打开文件接口

```c
int do_openat(int fd, char *file_name, int mode);
```

​		fd为指定搜索目录的文件描述符，file_name为待打开文件路径名，mode为打开文件方式。

​		`do_openat`函数执行时，首先根据文件路径名判断待打开的是SD卡文件还是设备文件。如果为设备文件，则调用`open_device`函数打开该设备；否则，调用`find_dirent_with_create_i`接口从SD卡上找到对应路径目录项。如果没有找到且`mode`不包含`O_CREATE`参数，则返回-1。找到后，调用`acquire_file`函数从打开文件列表中分配一个空的文件项，调用`acquire_fd`为该文件在当前进程中分配一个文件描述符。之后，根据`mode`参数确定该文件的属性。最后，返回分配的文件描述符。

（2）、文件读取接口

```c
int read_file(file *file, void *buf, uint rsize);
```

​		file为指向读取文件的指针，buf为读取目的地，rsize为读取数据字节数。

​		`read_file`函数执行时，首先判断参数和文件属性是否正确。之后，根据文件类型，确定使用下层的哪个接口。如果文件为SD卡类型，则使用`read_by_dirent_i`函数；如果为设备类型，则根据设备号在设备列表中索引对应设备的读函数指针进行读写；如果为管道类型，则使用`read_from_pipe`函数；如果类型非法，返回-1。成功读取后，将实际读取的字节数返回即可。

（3）、文件写入接口

```c
int write_file(file *file, void *buf, uint wsize);
```

​		file为指向写入文件的指针，buf为写入来源，wsize为写入数据字节数。

​		`write_file`函数执行时，首先判断参数和文件属性是否正确。之后，根据文件类型，确定使用下层的哪个接口。如果文件为SD卡类型，则使用`write_by_dirent_i`函数；如果为设备类型，则根据设备号在设备列表中索引对应设备的写函数指针进行读写；如果为管道类型，则使用`write_to_pipe`函数；如果类型非法，返回-1。成功写入后，将实际写入的字节数返回即可。		

（4）、关闭文件接口

```c
int do_close(int fd);
```

​		fd为当前进程中待关闭文件的文件描述符。

​		`do_close`执行时，首先根据`fd`索引到文件对应的`file`结构体项，然后调用`release_file`释放文件。最后将fd在进程打开文件列表中对应的那一项置为`NULL`。执行成功后返回0，否则返回-1。

​		`release_file`执行时，首先递减该文件的引用数。如果引用数降为0，则根据文件类型调用底层接口彻底释放文件。如果文件为SD卡类型，则使用`release_dirent_i`函数；如果为设备类型，则直接退出函数；如果为管道类型，则使用`close_pipe`函数；如果类型非法，直接退出函数。

（5）、其他接口简介

在指定进程中复制文件描述符：

```c
int do_dup(process *proc, int fd);
int do_dup3(process *proc, int old, int new);
```

创建目录：

```c
int do_mkdirat(int fd, char *path);
```

删除文件：

```c
int do_unlinkat(int dir_fd, char *path, int flags);
```

获取进程当前工作目录:

```c
char* do_getcwd(char *buf, int sz);
```

改变进程当前工作目录：

```c
int do_chdir(char *path);
```

获取文件详细信息：
```c
int do_fstat(int fd, kstat *kstat);
```



### 六、系统调用层

​		系统调用层本身的任务十分简单，仅仅是将用户态传来的参数做进一步的处理，如将虚拟地址转换为用户地址，以及用文件描述符在进程打开文件列表中索引到文件对应的`file`结构体指针。然后将参数传递给更下层的接口函数完成相应的任务，再将下层传回的返回值返回给用户进程就可以了。