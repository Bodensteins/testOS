# 内存管理说明文档

+ ### 物理内存
  
  + #### 初始化
      ​		内核将物理内存按照一页4K来管理；初始化的时候将内核所占空间之后的空间的128M即32K个页经过页对齐后全部填充初值1，内存的最高地址为PHYSTOP。并将所有页组织成一个空闲页链表，使每一个页的首地址里的内容是链表中下一个页的首地址。
  + #### 分配
      ​		分配当前空闲页链表的链头页，将其首地址返回，并将链头页更新为原链头页指向的下一个页。
  + #### 回收
      ​		将目标页全部填充初值1，然后将该页置为空闲页链表的链头页，使其首地址的内容是空闲页链表的原链头页首地址。
+ ### 虚拟内存
  
  + #### 内核地址空间
      ​		内核在初始化阶段会初始化内核的地址空间。由于内核拥有系统的控制权，所以内核的虚拟地址空间基本上全部映射到与之相等的物理地址空间。其中包括一些设备的控制寄存器的内存地址如串口、时钟，它们是可读可写的；内核代码段的地址空间，它是可读可执行的；内核代码段之后到PHYSTOP的地址空间，它们是可读可写可执行的。而用于trap的TRAMPOLINE段则会被映射到内核虚拟地址空间的顶端，它是可读可执行的。
  + #### 进程地址空间
      ​		进程地址空间的起始虚拟地址为0，地址向下依次递增。首先是代码段，然后是全局数据段，然后是堆段，然后是未分配的地址空间，可用于堆段的动态增缩，再是用户栈段，大小为固定的一页，接下来是TRAPFRAME段，分配一页，用于进入内核态时保存进程现场，最后是TRAMPOLINE段，即用户态和内核态间的跳板代码，分配一页，被映射在虚拟地址最高处。
  + #### 地址空间的映射与解除映射
      ​		RISC-V页表硬件通过把虚拟地址映射到物理地址的方式来把它们连接在一起。内核采用Sv39的分页方式，这种分页方式只使用64位虚拟地址里的低39位，高25位并未使用。在这39位有效位里，低12位是offset，剩下27位是index，这意味着每个页表在逻辑上对应着个PTE(页表入口)。Sv39的页表在物理内存里实际存在的形式是三级树(three-level tree)。树根是个4K的页，包含了512个PTE，每个PTE都对应了第二级的1个页，每个页都包含了第三级的512个PTE。虚拟地址的27位index里，高9位用来选择树根的PTE，中间9位用来选择二级页表页的PTE，低9位用来选择最终的PTE。内核和每个进程都有自己的页表，把页表的物理首地址放到satp寄存器里使页表生效，然后用指令sfence.vma刷新当前的TLB硬件就能使用对应的页表。
      &nbsp;
      ​		内核在初始化一个进程时，会初始化它的地址空间，首先为其分配所需的物理内存，然后将物理地址映射到设定的虚拟地址上。TRAMPOLINE段是一个特例，它不用分配物理内存，因为内核和所有的进程共用一个TRAMPOLINE段，它的物理内存已经在内核初始化时分配好了，初始化进程时只需将其物理内存映射到进程虚拟地址空间的顶端。
      &nbsp;
      ​		地址映射的关键函数是map_pages()，它把指定页表中[va , va+sz)的虚拟地址区间映射到[pa，pa+sz)的物理地址区间，其中va是要映射的起始的虚拟地址，pa是要映射的起始物理地址，sz是要映射的地址空间的大小，va和pa会被页对齐，它将这一块虚拟地址空间以4KB为单位映射到物理页上去。其所调用的关键函数是find_pte(),find_pte()根据指定的页表pd、虚拟地址va，找到va在该页表中的pte并返回该pte的指针。map_pages()拿到该pte的指针后会使该pte指向目标物理地址。
      &nbsp;
      ​		在进程被撤销时或者要缩减堆段时内核会释放其占用的内存，解除地址映射。解除地址映射的关键函数是unmap_pages()，它会调用find_pte()根据va找到其在页表中的pte，然后将pte清0，并视参数is_free_pa的值判断是否回收该物理页。对于TRAMPOLINE段应该不回收，因为其他进程和内核还要使用TRAMPOLINE段，而其他部分则应该回收物理页。页表中所有虚拟地址都解除了映射关系之后还应该释放页表自身占用的物理页。
  
  
    + #### 地址空间的通信
        ​        地址空间之间的通信的实质是让不同的地址空间之间共享数据。TRAMPOLINE段和管道都是地址空间通信的例子，其中TRAMPOLINE段的特征是所有进程的TRAMPOLINE段物理地址相同，虚拟地址也相同，管道的特征是两个进程以内核地址空间为中转站来传递数据。此外，在包含结构体类型参数和返回值的系统调用中，由于一个结构体可能被两个物理上不相邻的虚拟页“截断”，内核需要处理这种情形。内核的做法是找到进程的地址空间里该结构体对应的那两个物理页，直接往那两个物理页里写数据，这样就能正确地传递结构体数据。
