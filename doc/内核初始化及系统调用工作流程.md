# 内核初始化及系统调用工作流程



## 启动初始化

+ ### k210
    ​		riscv分为M态，S态和U态，我们采用的rustsbi运行在M态，内核运行在S态，应用程序运行在U态，由rustsbi实现的BootLoader功能让内核跑在K210板子上。链接脚本/tools/kernel-k210.ld指定了入口点为entry，并将链接目标的起始地址设为0x80020000，编译出来的内核镜像的入口点就在这里。entry在/kernel/entry.s中定义，它的工作是为内核分配栈空间，然后进入s_start()进行系统的初始化配置，包括设备、内存、进程、中断、文件系统，然后创建并调度第一个进程投入运行。自此内核的启动及初始化流程完毕。



## 系统调用

+ ### 系统调用的工作流程
    ​		系统调用方式遵循RISC-V ABI,即调用号存放在a7寄存器中,6个参数分别储存在a0-a5寄存器中,返回值保存在a0中。应用程序在运行的时候，如果想要使用系统调用提供的服务，那么就应该把参数放到a0-a5寄存器里，把调用号放到a7寄存器里，然后使用ecall指令。CPU的ecall指令做了4件事，从U态切换到S态，把当前的指令地址保存在sepc寄存器，将scause寄存器的值设置为8，跳转到stvec寄存器里存放的指令地址，这个地址在内核调度每个进程投入运行的时候被设置为user_trap_vec的首地址也就是trampoline段的首地址。然后从user_trap_vec进入到user_trap(),由于执行ecall指令的时候scause的值被设置为8，所以会进入系统调用处理流程handle_syscall()。在这里该进程的上下文中的sepc的值会被加4，因为与异常和设备中断不同的是，系统调用返回之后不应该再次执行原来的指令ecall，而应该执行下一个指令，所以该进程的上下文中的sepc的值要加4，在这之后内核会根据a7中的系统调用号调用对应的系统调用函数，并在该系统调用函数结束后将该函数的返回值放到a0里。最后内核会沿着user_trap_ret()->switch_to()->return_to_user()的函数调用链重新调度这个进程投入运行，应用程序从a0中取出预期的系统调用返回值，然后继续往下执行。自此，整个系统调用的工作流程介绍完毕。