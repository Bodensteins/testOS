# <center> TestOS说明文档 </center>

## 启动初始化

+ ### k210
    riscv分为M态，S态和U态，我们采用的rustsbi运行在M态，内核运行在S态，应用程序运行在U态，由rustsbi实现的BootLoader功能让内核跑在K210板子上。链接脚本/tools/kernel-k210.ld指定了入口点为entry，并将链接目标的起始地址设为0x80020000，编译出来的内核镜像的入口点就在这里。entry在/kernel/entry.s中定义，它的工作是为内核分配栈空间，然后进入s_start()进行系统的初始化配置，包括设备、内存、进程、中断、文件系统，然后创建并调度第一个进程投入运行。自此内核的启动及初始化流程完毕。
## 中断

+ ### 初始化
    内核在系统初始化时会进行trap初始化，首先设置sstatus寄存器和SIE寄存器的值以使能S态中断和U态中断。然后将stvec寄存器的值设置为内核中断跳板kernel_trap_vec()的首地址，因为目前系统处于内核态需要处理内核态的中断。最后设置下一次时钟中断的时间间隔。
+ ### 用户态中断
    当内核调度某个进程开始运行时，它会把用户中断跳板user_trap_vec()也就是TRAMPOLINE段的首地址放进stvec寄存器，以便发生用户态中断的时候CPU跳转到这里运行.然后在该进程的trapframe页里保存一些重要信息如内核页表,最后进入return_to_user(),切换运行该进程的页表，恢复该进程的上下文，执行sret执行新创建的进程第一条指令或者回到之前运行过的进程的发生中断的地方继续往下运行。
    &nbsp;
    进程在运行的时候可能发生三种trap，异常、系统调用和设备中断。设备中断又分为时钟中断和其他设备中断。在进程运行的时候，如果发生中断，由于在进程运行之前stvec寄存器的值是user_trap_vec()的首地址，所以CPU会跳转到这里执行，这一部分的代码会将进程的上下文保存在进程的虚拟地址空间中的trapframe页里，最后会切换运行内核的页表，进入真正的用户态trap处理函数user_trap()。这一部分的代码首先会把进程发生中断处的指令地址即sepc的值保存至该进程的trapframe，将stvec的值置为kernel_trap_vec()因为内核在进行中断处理的时候可能发生内核态中断。然后读取scause寄存器的值判断中断发生的原因是异常还是系统调用还是时钟中断还是设备中断，分别进入对应的处理流程中去。值得一提的是，如果是时钟中断，那么当该进程时间片到了的时候内核会将该进程置于就绪态，然后去调度其他进程投入运行。在处理完中断且时间片没到，内核会将该进程投入运行恢复该进程的上下文，并执行sret指令使其回到中断发生处继续往下执行。
+ ### 内核态中断
    内核在运行时可能发生两种trap，异常和设备中断，设备中断又分为时钟中断和其他设备中断。在处于内核态时，系统将stvec的值置为kernel_trap_vec()的首地址，当系统发生中断时，CPU进入kernel_trap_vec执行指令，这一部分的代码是工作是保存现场上下文，并进入真正的内核trap处理函数kernel_trap()，它先保存sepc和sstatus值以便发生中断嵌套的时候将来能够恢复这次中断的这两个寄存器的值，然后通过scause的值判断是时钟中断还是其他设备中断或者指令异常，如果是异常的话就panic，如果是前面两种中断的话就进入对应的处理流程。然后恢复sepc和sstatus寄存器的值，恢复发生内核中断处的上下文，然后调用sret回到发生内核中断的地方继续往后执行。
## 进程管理

+ ### 初始化
  
+ ### 进程创建
  
  + #### 第一个进程
  + #### fork
  + #### clone
  + #### exec
  
+ ### 进程切换
  
+ ### 进程撤销
  
+ ### 进程同步

## 内存管理

+ ### 物理内存
  
  + #### 初始化
      内核将物理内存按照一页4K来管理；初始化的时候将内核所占空间之后的空间的128M即32K个页经过页对齐后全部填充初值1，内存的最高地址为PHYSTOP。并将所有页组织成一个空闲页链表，使每一个页的首地址里的内容是链表中下一个页的首地址。
  + #### 分配
      分配当前空闲页链表的链头页，将其首地址返回，并将链头页更新为原链头页指向的下一个页。
  + #### 回收
      将目标页全部填充初值1，然后将该页置为空闲页链表的链头页，使其首地址的内容是空闲页链表的原链头页首地址。
+ ### 虚拟内存
  
  + #### 内核地址空间
      内核在初始化阶段会初始化内核的地址空间。由于内核拥有系统的控制权，所以内核的虚拟地址空间基本上全部映射到与之相等的物理地址空间。其中包括一些设备的控制寄存器的内存地址如串口、时钟，它们是可读可写的；内核代码段的地址空间，它是可读可执行的；内核代码段之后到PHYSTOP的地址空间，它们是可读可写可执行的。而用于trap的TRAMPOLINE段则会被映射到内核虚拟地址空间的顶端，它是可读可执行的。
  + #### 进程地址空间
      进程地址空间的起始虚拟地址为0，地址向下依次递增。首先是代码段，然后是全局数据段，然后是堆段，然后是未分配的地址空间，可用于堆段的动态增缩，再是用户栈段，大小为固定的一页，接下来是TRAPFRAME段也叫内核栈段，分配一页，用于进入内核态时保存进程现场，最后是TRAMPOLINE段，即用户态和内核态间的跳板代码，分配一页，被映射在虚拟地址最高处。
  + #### 地址空间的映射与解除映射
      RISC-V页表硬件通过把虚拟地址映射到物理地址的方式来把它们连接在一起。内核采用Sv39的分页方式，这种分页方式只使用64位虚拟地址里的低39位，高25位并未使用。在这39位有效位里，低12位是offset，剩下27位是index，这意味着每个页表在逻辑上对应着个PTE(页表入口)。Sv39的页表在物理内存里实际存在的形式是三级树(three-level tree)。树根是个4K的页，包含了512个PTE，每个PTE都对应了第二级的1个页，每个页都包含了第三级的512个PTE。虚拟地址的27位index里，高9位用来选择树根的PTE，中间9位用来选择二级页表页的PTE，低9位用来选择最终的PTE。内核和每个进程都有自己的页表，把页表的物理首地址放到satp寄存器里，然后用指令sfence.vma刷新当前CPU的TLB以使页表生效，硬件就能使用对应的页表。
      &nbsp;
      内核在初始化一个进程时，会初始化它的地址空间，首先为其分配所需的物理内存，然后将物理地址映射到设定的虚拟地址上。TRAMPOLINE段是一个特例，它不用分配物理内存，因为内核和所有的进程共用一个TRAMPOLINE段，它的物理内存已经在内核初始化时分配好了，初始化进程时只需将其物理内存映射到进程虚拟地址空间的顶端。
      &nbsp;
      地址映射的关键函数是map_pages()，它把指定页表中[va , va+sz)的虚拟地址区间映射到[pa，pa+sz)的物理地址区间，其中va是要映射的起始的虚拟地址，pa是要映射的起始物理地址，sz是要映射的地址空间的大小，va和pa会被页对齐，它将这一块虚拟地址空间以4KB为单位映射到物理页上去。其所调用的关键函数是find_pte(),find_pte()根据指定的页表pd、虚拟地址va，找到va在该页表中的pte并返回该pte的指针。map_pages()拿到该pte的指针后会使该pte指向目标物理地址。
      &nbsp;
      在进程被撤销时或者要缩减堆段时内核会释放其占用的内存，解除地址映射。解除地址映射的关键函数是unmap_pages()，它会调用find_pte()根据va找到其在页表中的pte，然后将pte清0，并视参数is_free_pa的值判断是否回收该物理页。对于TRAMPOLINE段应该不回收，因为其他进程和内核还要使用TRAMPOLINE段，而其他部分则应该回收物理页。页表中所有虚拟地址都解除了映射关系之后还应该释放页表自身占用的物理页。


  + #### 地址空间的通信
      地址空间之间的通信的实质是让不同的地址空间之间共享数据。TRAMPOLINE段和管道都是地址空间通信的例子，其中TRAMPOLINE段的特征是所有进程的TRAMPOLINE段物理地址相同，虚拟地址也相同，管道的特征是两个进程以内核地址空间为中转站来传递数据。此外，在包含结构体类型参数和返回值的系统调用中，由于一个结构体可能被两个物理上不相邻的虚拟页“截断”，内核需要处理这种情形。内核的做法是找到进程的地址空间里该结构体对应的那两个物理页，直接往那两个物理页里写数据，这样就能正确地传递结构体数据。
## 文件系统

+ ### 用户接口层
  
+ ### file层
  
+ ### inode层
    inode层是一个承上启下的层，对下它封装了fat32文件系统，对上它提供了标准的inode信息。inode层的核心是vfs_inode这个结构体，它将fat32的簇转换成标准inode的块，然后为每一个inode设置了一个inode号，文件系统的根目录的inode号被初始化为0。上层要访问fat32文件系统时，它们会首先访问inode层，然后由inode层去访问fat32层，然后更新inode层的状态以及向上返回访问fat32的结果。所以这一层的核心目的就是在上层访问fat32文件系统的过程中抽象出inode，然后提供get_inode_by_ino()和get_inode_by_dirent()两个接口让上层使用inode号或者fat32的dirent信息来查询对应的inode信息。
+ ### fat32层
  
+ ### buffer层
  
+ ### sd卡驱动层
  
  
## 设备管理

+ ### 设备作为特殊文件

+ ### 控制台

## 管道

+ ### 管道作为特殊文件

+ ### 管道的实现机制
  
  + #### 创建
  + #### 读写
  + #### 关闭

## 系统调用

+ ### 系统调用的工作流程
    系统调用方式遵循RISC-V ABI,即调用号存放在a7寄存器中,6个参数分别储存在a0-a5寄存器中,返回值保存在a0中。应用程序在运行的时候，如果想要使用系统调用提供的服务，那么就应该把参数放到a0-a5寄存器里，把调用号放到a7寄存器里，然后使用ecall指令。CPU的ecall指令做了4件事，从U态切换到S态，把当前的指令地址保存在sepc寄存器，将scause寄存器的值设置为8，跳转到stvec寄存器里存放的指令地址，这个地址在内核调度每个进程投入运行的时候被设置为user_trap_vec的首地址也就是trampoline段的首地址。然后从user_trap_vec进入到user_trap(),由于执行ecall指令的时候scause的值被设置为8，所以会进入系统调用处理流程handle_syscall()。在这里该进程的上下文中的sepc的值会被加4，因为与异常和设备中断不同的是，系统调用返回之后不应该再次执行原来的指令ecall，而应该执行下一个指令，所以该进程的上下文中的sepc的值要加4，在这之后内核会根据a7中的系统调用号调用对应的系统调用函数，并在该系统调用函数结束后将该函数的返回值放到a0里。最后内核会沿着user_trap_ret()->switch_to()->return_to_user()的函数调用链重新调度这个进程投入运行，应用程序从a0中取出预期的系统调用返回值，然后继续往下执行。自此，整个系统调用的工作流程介绍完毕。


# <center>作品特征描述</center>
我们队做的这个作品是一个riscv架构的操作系统内核，它能够在k210开发板上正常工作，实现了内存管理、进程管理、文件管理、设备管理等功能。其中，内存管理采用的是段页式，进程管理采用的是FIFO算法，文件系统实现的是FAT32文件系统并且实现了VFS的雏形，设备管理目前支持时钟和控制台而且其他的设备可以很容易地添加到现有的设备管理模块中。这些功能为应用程序的运行提供了所需的运行环境，使它们能够正确地并发运行并且合法访问系统资源以满足自身需要。

# <center>提交仓库目录和文件描述</center>
## doc
存放的是一些文档和图片
## kernel
存放的是内核源代码和sbi以及SD卡驱动的代码
+ ### include
    存放的是内核源代码的头文件
+ ### mcode
    存放的是内核在qemu上启动所必需的M态相关的代码
+ ### rustsbi
    存放的是rustsbi的可执行程序，用来提供内核在K210运行的M态环境
+ ### sd
    存放的是SD卡驱动的源代码和头文件
+ ### buffer.c
    文件系统buffer层的代码
+ ### console.c
    控制台输入输出的代码
+ ### device.c
    设备管理的代码
+ ### entry.S
    内核入口代码
+ ### fat32.c
    文件系统fat32层的代码
+ ### file.c
    文件系统file层的代码
+ ### kerneltrapvec.S
    内核态中断的跳板代码
+ ### load_store.S
    保存上下文中所有通用寄存器的代码
+ ### pipe.c
    管道的代码
+ ### plic.c
    PLIC的代码
+ ### pm.c
    物理内存管理的代码
+ ### printk.c
    内核打印功能的代码
+ ### process.c
    进程管理的代码
+ ### schedule.c
    进程调度的代码
+ ### sleeplock.c
    睡眠锁的代码
+ ### spinlock.c
    自旋锁的代码
+ ### sstart.c
    内核初始化的代码
+ ### string.c
    内核中字符串处理相关的代码
+ ### syscall.c
    系统调用的代码
+ ### sysexec.c
    将elf文件加载为进程的代码
+ ### sysmmap.c
    内存映射文件的代码
+ ### systime.c
    时钟相关的代码
+ ### trap.c
    中断相关的代码
+ ### usertrapvec.S
    用户态中断的跳板代码
+ ### vfs_inode.c
    文件系统inode层的代码
+ ### vm.c
    虚拟内存管理的代码
## target
编译内核后生成的目标文件
## tools
链接脚本
## user
一些应用程序

